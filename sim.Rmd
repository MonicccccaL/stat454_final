---
title: "House pricing: simulation activity in R"
description: |
---

# Spatial Modeling of Housing Prices {#sim}

-   *Goal*: estimate housing prices in Hennepin and Ramsey county, Minneapolis, Minnesota using the **BYM** spatial model with **R-INLA** packages.

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=TRUE)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
library(sf) #install.packages('sf')
library(spdep) #install.packages('spdep')
library(GGally)
library(tidyr)
library(INLA)
library(mapview)
library(Matrix)
library(leafsync)
library(spatialreg)
```

## Housing Price Data in Hennepin and Ramsey county, Minneapolis, Minnesota

The Hennepin and Ramsey housing prices are gathered aggregate summaries of the people who live in Hennepin and Ramsey county, summarized for each census tract based on data from 2015-2019 American Community Service run by the U.S. Census Bureau. A census tract is a statistical subdivision of a county that aims to have roughly 4,000 inhabitants and they are intended to be fairly homogeneous with respect to demographic and economic conditions. #need revision

```{r}
load('SpatialData.RData')
ggplot(mn_data, aes(x=HouseValueE))+
  geom_density()
```

This dataset contains housing data of 464 Hennepin and Ramsey census tracts including median prices of housing in USD (`HouseValueE`), median household income in the past 12 months (in 2019 inflation) (`IncomeE`), and average household size of occupied houses (`HouseholdSizeE`). We create the variable called `vble` with the logarithm of the median prices to put it in the same scale, and map the log price using **mapview** (Figure 1). The map suggests that the housing prices are greater in the southwest, and prices are related to those in neighboring areas. Noted that the empty area is the University of Minnesota area, since there is no houses listed.

*Figure 1 Logarithm of housing prices in Hennipin & Ramsey county, MN per census tract from the spData package*

```{r}
mn_data$vble <- log(mn_data$HouseValueE)
mapview(mn_data, zcol = "vble")
```

We will model the logarithm of the median prices using as covariates the average Median household income in the past 12 months (IncomeE) and the average household size (HouseholdSizeE). Figure 2 shows the relationships between pairs of variables visualized using the ggpairs() function of the GGally package (Schloerke et al. 2021). We observe a negative relationship between the logarithm of housing price and crime, and a positive relationship between the logarithm of housing price and the average number of rooms.

*Figure 2 Relationship betwen the outcome variable logarithm of housing price (vble), and the average Median household income in the past 12 months (IncomeE) and the average household size (HouseholdSizeE)*

```{r}
# Find relationship of crime rate and number of rooms with log(house price)
ggpairs(data = mn_data, columns = c("vble", "HouseholdSizeE", "IncomeE"))
```

## Model

Let $Y_i$ be the logarithm of housing price of area $i$, $i = 1 , \dots, n$. We fit a BYM model that considers $Y_i$ as the response variable, and household income and household size as covariates:
$$
Y \sim N(\mu_i,\sigma^2), i = 1, \dots, n \\
\mu_i=\beta_0+\beta_1 \times Income+\beta_2 \times HouseholdSize + u_i+v_i
$$
where, (Question? does this mean that each household has a seperate intercept)
- $\beta_0$: the global intercept, which every household will have the same intercept.
- $\beta_1$, $\beta_2$: represent respectively, the coefficients of the covariates household income and household size.
- $\mu_i$: a spatially structured effect modeled with a CAR structure,$\mu_i| u_{-i} \sim N(\mu_{\delta_i}, \frac{\sigma^2_u}{n_{\delta_i}})$. 
- $v_i$: an unstructured effect modeled as $v_i \sim N(\theta, \sigma^2_v)$.

## Neighborhood Matrix

We decided to use Queen neighborhood structure, which ...

*Figure 3 Neighborhood Network Structure*

In the model, the spatial random effect $u_i$ needs to be specified using a neighborhood structure. As we mentioned in the spatial model section, there are **3** commmon neighborhood structure: Queen, Rook, and Bishop. Here, we assume two areas are neighbors if they share a common edge or a common vertex. We create a neighborhood structure using functions of the **spdep** package (Bivand 2022). 

First, we use the poly2nb() function to generate a spatial weights matrix (nb) based on the data (mn_data) and using queen contiguity to define neighborhood relationships between polygons. Each element of the list nb represents one area and contains the indices of its neighbors. For example, nb[[1]] contains indices of neighboring polygons in area 1.

```{r}
# Neighborhood
nb <- poly2nb(mn_data, queen = TRUE)
head(nb, 3)
```

Figure 3 shows a map with the neighbors obtained. This plot is obtained by first plotting the map of Ramsey and Hennipin, and then overlapping the queen neighborhood structure with the plot.nb() function passing the neighbor list and the coordinates of the map.

```{r}
plot(st_geometry(mn_data), border = "black")
plot.nb(nb, st_geometry(mn_data), add = TRUE)
```

To construct the neighborhood matrix that can be used in the INLA function, we use the nb2INLA() function to convert the nb list into a file called map.adj. This step will make sure that we  have the representation of the neighborhood matrix as required by R-INLA. The map.adj file is saved in the working directory which can be obtained with getwd(). Then, we read the map.adj file using the inla.read.graph() function of R-INLA, and store it in the object g which we later use to specify the spatial model using R-INLA.

```{r}
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")

mn_data$re_u <- 1:nrow(mn_data)
mn_data$re_v <- 1:nrow(mn_data)

prior <- list(
  prec = list(
    prior = "pc.prec",
    param = c(0.5 / 0.31, 0.01)),
  phi = list(
    prior = "pc",
    param = c(0.5, 2 / 3))
  )

# Specify BYM model
formula <- vble ~ 
  f(re_u, model = "besag", graph = g, scale.model = TRUE) +
  f(re_v, model = "iid")

formula <- vble ~ f(re_u, model = "bym2", graph = g, hyper = prior)

res <- inla(formula, family = "gaussian", data = mn_data,
            control.predictor = list(compute = TRUE),
            control.compute = list(return.marginals.predictor = TRUE))

res$summary.fixed
summary(res$summary.fitted.values)

# Posterior mean and 95% CI
mn_data$PM <- res$summary.fitted.values[, "mean"]
mn_data$LL <- res$summary.fitted.values[, "0.025quant"]
mn_data$UL <- res$summary.fitted.values[, "0.975quant"]
```

```{r}
mapsf <- st_as_sf(mn_data)

gRR <- ggplot(mn_data) + geom_sf(aes(fill = PM)) +
  scale_fill_gradient2( midpoint = 12.5,low = "blue", high = "red") +
  theme_bw()
gLL <- ggplot(mn_data) + geom_sf(aes(fill = LL)) +
  scale_fill_gradient2(midpoint = 12.5, low = "blue", high = "red") +
  theme_bw()
gUL <- ggplot(mn_data) + geom_sf(aes(fill = LL)) +
  scale_fill_gradient2(midpoint = 12.5, low = "blue", high = "red") +
  theme_bw()

library(cowplot)
plot_grid(gRR, gLL, gUL, ncol = 1)
```



```{r}
# common legend
at <- seq(min(c(mn_data$PM, mn_data$LL, mn_data$UL)),
          max(c(mn_data$PM, mn_data$LL, mn_data$UL)),
          length.out = 8)

# popup table
popuptable <- leafpop::popupTable(dplyr::mutate_if(mn_data,
                                  is.numeric, round, digits = 2),
zcol = c("NAME", "vble", "HouseholdSizeE", "IncomeE", "PM", "LL", "UL"),
row.numbers = FALSE, feature.id = FALSE)

m1 <- mapview(mn_data, zcol = "PM", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m2 <- mapview(mn_data, zcol = "LL", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m3 <- mapview(mn_data, zcol = "UL", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)

m <- leafsync::sync(m1, m2, m3, ncol = 3)
m
```

```{r}
# Transformation of the marginal of
# the first area with inla.tmarginal()
# inla.tmarginal(function(x) exp(x),
#                res$marginals.fitted.values[[1]])

# Transformation marginals with inla.tmarginal()
marginals <- lapply(res$marginals.fitted.values,
FUN = function(marg){inla.tmarginal(function(x) exp(x), marg)})

# Obtain summaries of the marginals with inla.zmarginal()
marginals_summaries <- lapply(marginals,
FUN = function(marg){inla.zmarginal(marg)})

# Posterior mean and 95% CI
mn_data$PMoriginal <- sapply(marginals_summaries, '[[', "mean") 
mn_data$LLoriginal <- sapply(marginals_summaries, '[[', "quant0.025")
mn_data$ULoriginal <- sapply(marginals_summaries, '[[', "quant0.975")

# common legend
at <- seq(min(c(mn_data$PMoriginal, mn_data$LLoriginal, mn_data$ULoriginal)),
          max(c(mn_data$PMoriginal, mn_data$LLoriginal, mn_data$ULoriginal)),
          length.out = 8)

# popup table
popuptable <- leafpop::popupTable(dplyr::mutate_if(mn_data,
                                  is.numeric, round, digits = 2),
zcol = c("NAME", "vble", "HouseholdSizeE", "IncomeE", "PM", "LL", "UL"),
row.numbers = FALSE, feature.id = FALSE)

m1 <- mapview(mn_data, zcol = "PMoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m2 <- mapview(mn_data, zcol = "LLoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m3 <- mapview(mn_data, zcol = "ULoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
leafsync::sync(m1, m2, m3, ncol = 3)
```

------------------------------------------------------------------------

# Conclusion
