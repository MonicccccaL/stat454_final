---
title: "House pricing: simulation activity in R"
description: |
---

# Spatial Modeling of Housing Prices {#sim}

-   *Goal*: estimate housing prices in Hennepin and Ramsey county, Minneapolis, Minnesota using the **BYM** spatial model with **R-INLA** packages.

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=TRUE, warning=FALSE)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
library(sf) #install.packages('sf')
library(spdep) #install.packages('spdep')
library(GGally)
library(tidyr)
library(INLA)
library(mapview)
library(Matrix)
library(leafsync)
library(spatialreg)
```

## Housing Value Data in Twins Cities

Our project apply the methodology we previously talk about to the housing value data as a simulation. The regions we focus on are the Ramsey County and Hennepin County, roughly Twins Cities area, in Minnesota. The housing value are gathered aggregate summaries of the people who live in these two counties, summarized for each census tract based on 2015-2019 American Community Service (ACS) 5-year data set run by the U.S. Census Bureau. A census tract is a statistical subdivision of a county that aims to have roughly 4,000 inhabitants and they are intended to be fairly homogeneous with respect to demographic and economic conditions.

```{r}
load('SpatialData.RData')
ggplot(mn_data, aes(x=HouseValueE))+
  geom_density()
```

This data set contains housing data of 464 Hennepin and Ramsey census tracts including median prices of housing in USD, median household income in the past 12 months (in 2019 inflation), and average household size of occupied houses. We take the logarithm of the median housing prices to put it in the same scale. Figure 1 below maps the distribution of log house price in the focused regions. The map suggests that the housing prices are greater in the southwest, and prices are related to those in neighboring areas. Noted that the empty area is the University of Minnesota area, since there is no houses listed.

***Figure 1** Logarithm of housing prices in Hennipin & Ramsey county, MN per census tract from the spData package*

```{r}
mn_data$vble <- log(mn_data$HouseValueE)
mapview(mn_data, zcol = "vble", layer.name = "log price")
```

We will model the logarithm of the median prices using as covariates the average Median household income in the past 12 months and the average household size. Figure 2 shows the relationships between pairs of variables visualized using the `ggpairs()` function of the GGally package (Schloerke et al. 2021). We observe a negative relationship between the logarithm of housing price and crime, and a positive relationship between the logarithm of housing price and the average number of rooms.

***Figure 2** Relationship between the outcome variable logarithm of housing price, and the average Median household income in the past 12 months and the average household size.*

```{r}
ggpairs(data = mn_data, columns = c("vble", "HouseholdSizeE", "IncomeE"), columnLabels = c("log price", "Household Size", "Income"))
```

## General Model

Let $Y_i$ be the logarithm of housing price of area $i$, $i = 1 , \dots, n$. We fit a BYM model that considers $Y_i$ as the response variable, and household income and household size as covariates:

$$
Y_i \sim N(\mu_i,\sigma^2), i = 1, \dots, n \\
\text{where }\mu_i=\beta_0+\beta_1 \times Income_i+\beta_2 \times HouseholdSize_i + u_i+v_i
$$ 

where, (Question? does this mean that each household has a seperate intercept) - $\beta_0$: the global intercept, which every household will have the same intercept. - $\beta_1$, $\beta_2$: represent respectively, the coefficients of the covariates household income and household size. - $\mu_i$: a spatially structured effect modeled with a CAR structure,$\mu_i| u_{-i} \sim N(\mu_{\delta_i}, \frac{\sigma^2_u}{n_{\delta_i}})$. - $v_i$: an unstructured effect modeled as $v_i \sim N(\theta, \sigma^2_v)$.

## Neighborhood Matrix

We decided to use Queen neighborhood structure, which ...

In the model, the spatial random effect $u_i$ needs to be specified using a neighborhood structure. As we mentioned in the spatial model section, there are **3** commmon neighborhood structure: Queen, Rook, and Bishop. Here, we assume two areas are neighbors if they share a common edge or a common vertex. We create a neighborhood structure using functions of the **spdep** package (Bivand 2022).

First, we use the poly2nb() function to generate a spatial weights matrix (nb) based on the data (mn_data) and using queen contiguity to define neighborhood relationships between polygons. Each element of the list nb represents one area and contains the indices of its neighbors. For example, nb[[1]] contains indices of neighboring polygons in area 1.

```{r}
# Neighborhood
nb <- poly2nb(mn_data, queen = TRUE)
head(nb, 3)
```

Figure 3 shows a map with the neighbors obtained. This plot is obtained by first plotting the map of Ramsey and Hennipin, and then overlapping the queen neighborhood structure with the plot.nb() function passing the neighbor list and the coordinates of the map.

***Figure 3** Neighborhood Network Structure*

```{r fig.width=8, fig.height=8}
plot(st_geometry(mn_data), border = "black")
plot.nb(nb, st_geometry(mn_data), add = TRUE)
```

To construct the neighborhood matrix that can be used in the INLA function, we use the `nb2INLA()` function to convert the nb list into a file called map.adj. This step will make sure that we have the representation of the neighborhood matrix as required by R-INLA. The map.adj file is saved in the working directory. Then, we read the map.adj file using the `inla.read.graph()` function of R-INLA, and store it in the object g which we later use to specify neighborhood for the spatial model when using R-INLA.

```{r}
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
```

## inla() Call

We specify the model formula by including the outcome and the fixed and random effects. In the formula, random effects are specified with the `f()` function. The index vectors of the random effects `re_u` and `re_v` are respectively created for spatial random effect, $u_i$, and unstructured effect, $v_i$. These vectors are equal to the number of areas from `mn_data`.

For $u_i$ , we use `model = "besag"`, a popular model for spatial autocorrelation, with neighborhood matrix given by $g$ form the previous code. The option `scale.model = TRUE` is used to scale the precision parameter of models, making the spatial effects of models with different CAR priors comparable. For $v_i$ , we choose `model = "iid"`, which assuming there is no spatial autocorrelation structure.

```{r}
mn_data$re_u <- 1:nrow(mn_data)
mn_data$re_v <- 1:nrow(mn_data) 

# set up spatial model
formula <- vble ~ IncomeE + HouseholdSizeE +
  f(re_u, model = "besag", graph = g, scale.model = TRUE) +
  f(re_v, model = "iid")
```

In R-INLA, the BYM model can also be specified with `model = "bym"` and this comprises both the spatial and unstructured components. Alternatively, we can use the BYM2 model (Simpson et al. 2017) which is a reparametrization of the BYM model that uses a scaled spatial component $u_∗$ and an unstructured component $v_∗$, which allows for separate inference on the spatial and unstructured components. The formula of the model using the BYM2 component is specified as follows:

```{r}
# specify BYM
formula <- vble ~ IncomeE + HouseholdSizeE + 
  f(re_u, model = "bym2", graph = g)
```

Then, we fit the model by calling the inla() function specifying the formula to the spatial formula we previously specified, the family to Gaussian (normal), and the data to `mn_data`. Here, since we don't have information on our prior, we will use the default Gaussian prior with mean and precision equal to 0 in R-INLA (Moraga, 2023). We also set `control.predictor = list(compute = TRUE)` and `control.compute = list(return.marginals.predictor = TRUE)` to compute and return the posterior means of the predictors.

```{r}
res <- inla(formula, family = "gaussian", data = mn_data,
            control.predictor = list(compute = TRUE),
            control.compute = list(return.marginals.predictor = TRUE))
```

## Results

The resulting object `res` contains the fit of the model. We can use `summary(res)` to generate a summary of the fitted model. `res$summary.fixed` contains a summary of the fixed effects.

```{r}
res$summary.fixed
```

Here, we observe the intercept, $\hat \beta_0$, is $1.236$ with a 95% credible interval equal to (1.224, 1.248). We observe the coefficient of household income, $\hat \beta_1$, is $5.583 \times 10^{-6}$ with a 95% credible interval equal to ($4.907 \times 10^{-6}$, $6.257 \times 10^{-6}$). This indicates household income is statistically significantly, and it is positively related to housing price. We observe the coefficient of household size, $\hat \beta_2$, is $-0.0759$ with a 95% credible interval equal to (-0.127, -0.0247). This indicates household size is significantly negatively related to housing price.

We can use `res$summary.fitted.values` to obtain a summary of the posterior distributions of the response $\mu_i$ for each of the areas. Column `mean` indicates the posterior mean for housing values for each observation $i$. Columns `0.025quant` and `0.975quant` are the lower and upper limits of 95% credible intervals representing the uncertainty of the estimates obtained.

```{r}
summary(res$summary.fitted.values)
```

We create variables with the posterior mean (PM) and lower (LL) and upper (UL) limits of 95% credible intervals  for each observation $i$ that we observed from previous tables.

```{r}
# Posterior mean and 95% CI
mn_data$PM <- res$summary.fitted.values[, "mean"]
mn_data$LL <- res$summary.fitted.values[, "0.025quant"]
mn_data$UL <- res$summary.fitted.values[, "0.975quant"]
```

Then, we create maps of these variables with **mapview** specifying a common legend for the three maps, and using a popup table with the name, the logarithm of the housing prices, the covariates the household size and the household income, and the posterior mean and 95% credible intervals that creates in the previous code chunk. We use the `sync()` function of **leafsync** to plot synchronized maps.

```{r}
# common legend
at <- seq(min(c(mn_data$PM, mn_data$LL, mn_data$UL)),
          max(c(mn_data$PM, mn_data$LL, mn_data$UL)),
          length.out = 8)

# popup table
popuptable <- leafpop::popupTable(dplyr::mutate_if(mn_data,
                                  is.numeric, round, digits = 2),
zcol = c("NAME", "vble", "HouseholdSizeE", "IncomeE", "PM", "LL", "UL"),
row.numbers = FALSE, feature.id = FALSE)

m1 <- mapview(mn_data, zcol = "PM", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m2 <- mapview(mn_data, zcol = "LL", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m3 <- mapview(mn_data, zcol = "UL", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)

m <- leafsync::sync(m1, m2, m3, ncol = 3)
m
```

```{r}
# Transformation of the marginal of
# the first area with inla.tmarginal()
# inla.tmarginal(function(x) exp(x),
#                res$marginals.fitted.values[[1]])

# Transformation marginals with inla.tmarginal()
marginals <- lapply(res$marginals.fitted.values,
FUN = function(marg){inla.tmarginal(function(x) exp(x), marg)})

# Obtain summaries of the marginals with inla.zmarginal()
marginals_summaries <- lapply(marginals,
FUN = function(marg){inla.zmarginal(marg)})

# Posterior mean and 95% CI
mn_data$PMoriginal <- sapply(marginals_summaries, '[[', "mean") 
mn_data$LLoriginal <- sapply(marginals_summaries, '[[', "quant0.025")
mn_data$ULoriginal <- sapply(marginals_summaries, '[[', "quant0.975")

# common legend
at <- seq(min(c(mn_data$PMoriginal, mn_data$LLoriginal, mn_data$ULoriginal)),
          max(c(mn_data$PMoriginal, mn_data$LLoriginal, mn_data$ULoriginal)),
          length.out = 8)

# popup table
popuptable <- leafpop::popupTable(dplyr::mutate_if(mn_data,
                                  is.numeric, round, digits = 2),
zcol = c("NAME", "vble", "HouseholdSizeE", "IncomeE", "PM", "LL", "UL"),
row.numbers = FALSE, feature.id = FALSE)

m1 <- mapview(mn_data, zcol = "PMoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m2 <- mapview(mn_data, zcol = "LLoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m3 <- mapview(mn_data, zcol = "ULoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
leafsync::sync(m1, m2, m3, ncol = 3)
```

------------------------------------------------------------------------

# Conclusion
