---
title: "House pricing: simulation activity in R"
description: |
---

# Spatial Modeling of Housing Prices {#sim}

-   *Goal*: estimate housing prices in Hennepin and Ramsey county, Minneapolis, Minnesota using the **BYM** spatial model with **R-INLA** packages.

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=TRUE)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
library(sf) #install.packages('sf')
library(spdep) #install.packages('spdep')
library(GGally)
library(tidyr)
library(INLA)
library(mapview)
library(Matrix)
library(leafsync)
library(spatialreg)
```

## Housing Price Data in Hennepin and Ramsey county, Minneapolis, Minnesota

The Hennepin and Ramsey housing prices are gathered aggregate summaries of the people who live in Hennepin and Ramsey county, summarized for each census tract based on data from 2015-2019 American Community Service run by the U.S. Census Bureau. A census tract is a statistical subdivision of a county that aims to have roughly 4,000 inhabitants and they are intended to be fairly homogeneous with respect to demographic and economic conditions. #need revision

```{r}
load('SpatialData.RData')
```

This dataset contains housing data of 464 Hennepin and Ramsey census tracts including median prices of housing in USD (`HouseValueE`), median household income in the past 12 months (in 2019 inflation) (`IncomeE`), and average  household size of occupied houses (`HouseholdSizeE`). We create the variable called `vble` with the logarithm of the median prices to put it in the same scale, and map the log price using **mapview** (Figure 1). The map suggests that the housing prices are greater in the southwest, and prices are related to those in neighboring areas.

```{r}
mn_data$vble <- log(mn_data$HouseValueE)
mapview(mn_data, zcol = "vble")
```


```{r}
#
Queen <- poly2nb(mn_data, queen = TRUE)

mn_centroids <- st_centroid(st_geometry(mn_data), of_largest_polygon = TRUE)
nb_Q_net <- nb2lines(nb = Queen, coords = mn_centroids, as_sf = TRUE)

#Visualize network on the map (unfilled)
mn_data %>% 
  ggplot()+
  geom_sf()+
  geom_sf(data=nb_Q_net)+
  theme_classic()
```

```{r}
# Find relationship of crime rate and number of rooms with log(house price)
ggpairs(data = mn_data, columns = c("vble", "HouseholdSizeE", "IncomeE"))

nb <- poly2nb(mn_data)

mn_centroids <- st_centroid(st_geometry(mn_data), of_largest_polygon = TRUE)
dist_neigh <- dnearneigh(mn_centroids, d1 = 0, d2 = 1*5280)
g <- nb2lines(nb = nb, coords = mn_centroids, as_sf = TRUE)

#Visualize network on the map (unfilled)
mn_data %>% 
  ggplot()+
  geom_sf()+
  geom_sf(data=g)+
  theme_classic()

# # Neighborhood
nb <- poly2nb(mn_data)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")

# g <- nb2mat(nb, style = "C")

mn_data$re_u <- 1:nrow(mn_data)
mn_data$re_v <- 1:nrow(mn_data)


# Specify BYM model
formula <- vble ~ HouseholdSizeE + IncomeE + 
  f(re_u, model = "besag", graph = g, scale.model = TRUE) +
  f(re_v, model = "iid")

formula <- vble ~ HouseholdSizeE + IncomeE + 
  f(re_u, model = "bym2", graph = g)

res <- inla(formula, family = "gaussian", data = mn_data,
            control.predictor = list(compute = TRUE),
            control.compute = list(return.marginals.predictor = TRUE))

res$summary.fixed
summary(res$summary.fitted.values)

# Posterior mean and 95% CI
mn_data$PM <- res$summary.fitted.values[, "mean"]
mn_data$LL <- res$summary.fitted.values[, "0.025quant"]
mn_data$UL <- res$summary.fitted.values[, "0.975quant"]
```

```{r}
# common legend
at <- seq(min(c(mn_data$PM, mn_data$LL, mn_data$UL)),
          max(c(mn_data$PM, mn_data$LL, mn_data$UL)),
          length.out = 8)

# popup table
popuptable <- leafpop::popupTable(dplyr::mutate_if(mn_data,
                                  is.numeric, round, digits = 2),
zcol = c("NAME", "vble", "HouseholdSizeE", "IncomeE", "PM", "LL", "UL"),
row.numbers = FALSE, feature.id = FALSE)

m1 <- mapview(mn_data, zcol = "PM", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m2 <- mapview(mn_data, zcol = "LL", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m3 <- mapview(mn_data, zcol = "UL", map.types = "CartoDB.Positron",
              at = at, popup = popuptable)

m <- leafsync::sync(m1, m2, m3, ncol = 3)
m
```

```{r}
# Transformation of the marginal of
# the first area with inla.tmarginal()
# inla.tmarginal(function(x) exp(x),
#                res$marginals.fitted.values[[1]])

# Transformation marginals with inla.tmarginal()
marginals <- lapply(res$marginals.fitted.values,
FUN = function(marg){inla.tmarginal(function(x) exp(x), marg)})

# Obtain summaries of the marginals with inla.zmarginal()
marginals_summaries <- lapply(marginals,
FUN = function(marg){inla.zmarginal(marg)})

# Posterior mean and 95% CI
mn_data$PMoriginal <- sapply(marginals_summaries, '[[', "mean") 
mn_data$LLoriginal <- sapply(marginals_summaries, '[[', "quant0.025")
mn_data$ULoriginal <- sapply(marginals_summaries, '[[', "quant0.975")

# common legend
at <- seq(min(c(mn_data$PMoriginal, mn_data$LLoriginal, mn_data$ULoriginal)),
          max(c(mn_data$PMoriginal, mn_data$LLoriginal, mn_data$ULoriginal)),
          length.out = 8)

# popup table
popuptable <- leafpop::popupTable(dplyr::mutate_if(mn_data,
                                  is.numeric, round, digits = 2),
zcol = c("NAME", "vble", "HouseholdSizeE", "IncomeE", "PM", "LL", "UL"),
row.numbers = FALSE, feature.id = FALSE)

m1 <- mapview(mn_data, zcol = "PMoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m2 <- mapview(mn_data, zcol = "LLoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
m3 <- mapview(mn_data, zcol = "ULoriginal",
              map.types = "CartoDB.Positron",
              at = at, popup = popuptable)
leafsync::sync(m1, m2, m3, ncol = 3)
```

------------------------------------------------------------------------

# Conclusion
